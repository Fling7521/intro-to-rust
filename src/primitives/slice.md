# 切片 slice

用于存放相同数据类型的一堆数据. 包括两部分属性, 其一是数据类型, 其二是元素个数.
这些都是要在编译期确定的. 写法是: `[T; size]`.
其中的元素被存放在一段连续的内存中, 位于栈上, 所以其占用的内存大小受限.

初始化数组:

* 一次性确定所有元素, `let xs = [1, 2, 3, 5, 8, 13];`
* 使用默认值: `let xs = [1u64; 10];`

切片 slice, 可以认为是数组的访问代理, 本身并不存储实际的数据, 有两部分属性:
其一是指向具体数据的一个指针, 类型是 usize; 其二是该访问代理可访问的元素数目.
这两个属性都可以在运行期确定, 所以 slice 更为灵活. 被记为 `&[T]`.

可以将数组通过引用的方式自动转为 slice:

```rust
let xs = [42u64; 10];
let s = &xs;
```

也可以指定数据代理访问的范围, 即只允许访问其部分元素:

```rust
let xs = [42; 10];
let s = &xs[1..5];
```

Slice 写作 `[T]`, 只指定了元素类型, 并没有指定其长度；所以它不能直接存储为变量
或作为函数参数, 而应该以引用的方式来使用.

切片引用（Reference to slice）又称作胖指针（fat pointer）, 因为它既有指针指向
切片的第一个元素, 也记录其元素个数.

- 切片表示指向类似 array 或者 vector 的指针, 以及元素个数
- `&[T]` 表示不可变切片；一个值可以有多个不可变切片, 因为它们都是只读的
- `&mut [T]` 表示可变切片, 可修改元素的值；一个值只能最多有一个可变切片

会自动将 `&Vec<T>` 以及 `&[T]` 转换为切片引用.

array slice, 是两个 word 大小的对象, 第一个值是指向 array 内部某元素的指针; 第二
个值是定义长度. 类型签名是 `&[T]`.

array 可以直接转换 array slice:

```rust
fn do_something(slice: &[i32]) { }

let xs = [1, 1, 2, 3, 5];
do_something(&xs);
```

也可以只将array 的一部分元素转为 array slice:

```rust
fn do_something(slice: &[i32]) { }

let xs = [1, 1, 2, 3, 5];
do_something(&xs[1..3]);
```

其实 Slice 本身的类型签名是 `[T]`, 但在代码中并不能直接使用这个类型.
