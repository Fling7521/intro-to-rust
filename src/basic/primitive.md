
# 基本数据类型 Primitives

* char, Unicde char, 占用1到4个字节
* 可以用 _ 来分隔数值, 更具有可读性
* 可以有前缀, `0b01010`, `0xfead`
* 可以有后缀, 用于指定数据类型, `42u32`

## 标量类型
* 有符号整数: i8, i16, i32, i64, i128, isize(指针大小)
* 无符号整数: u8, u16, u32, u64, u128, usize(指针大小)
* char, Unicode 字符, 比如 `a`, (4字节), 使用单引号引用
* bool, 可以是 `true` 或 `false`
* unit type `()`, 就是一个空的 tuple

## bool
Rust 几乎不会进行隐式类型转换。

Rust 使用一个字节来表示布尔值，这样可以使用布尔值指针。

## Characters
一个 char 使用 32-bit 的空间。
一个 char 表示一个 Unicode code point，范围是：
0x0000 - 0xD7FF, 0xE000 - 0x10FFFF

只有 u8 类型可以用 `as` 来转换成 char。


## 复合数据类型
* array 数组, 比如 `[1, 2, 3, 4]`
* tuple 元组, 比如 `(1, 'a', true)


## 字面量与操作符
数值可以有一些修饰, 比如:
* 0x 前缀表示十六进制整数
* 0o 前缀表示八进制整数
* 0b 前缀表示二进制整数
* `123_000` 可以用下划线分隔, 更易读; 可以用于浮点数, ``0.0_121`
* 将整数值赋给一个变量时, 可以同时用整数类型作为后缀, 比如: `let x = 42u64;`
* 对于数值的操作符, 比如 `<<`, `&` 等, 跟在 C 语言中一致

## 元组 Tuples
元组跟在 C++ 中的一样, 用于存放不同数据类型的一堆数据. `(1, 2, false, 3.14)`

```rust
#[derive(Debug, Clone, Copy)]
struct Matrix(f64, f64, f64, f64);
```

tuple, 定长, 可以存放不同类型的数值: `struct Matrix(f64, f64, f64);`.
- 可以组合各种不同类型的数据，而 array 只能存放相同类型的数据
- 编译期即可确定其元素个数
- 使用下标访问元素，而不是像 struct 那样使用元素名来访问
- 常使用它做为函数返回值，这样函数就可以返回多个值了
- 空的 tuple，不包含任何元素，写成 `()`，也称为 `unit type`，有点类似于C中的 `void`

Rust 允许在使用逗号的地方，在最后一个元素尾部多加一个逗号，比如：
- `fn foo(a: i32, b:i32,);`
- `(48, 42,)`
- `enum Colors { Red, Green, Blue, }`
这样方使书写。

## 数组 Arrays
array, 定长, 只能存放相同类型的数值: `let v: [u32; 4] = [1, 1, 2, 3];`. 类型签名是 `[T; size]`.
其内存是分配在栈空间的; 内存是连续分配的, 其类型及大小是在编译期间就确定的.

- `[T; N]` array 在编译期确定元素类型及个数，且元素个数不可变
- 在编译期就需要初始化
- 可以显式地指定所有元素的值，`let arr = [1, 2, 3, 4, 5];`
- 可以一次性初始化成相同的值，`let arr = [42; 100];` 会创建有100个元素的数组，
元素的值都是42
- 数组的操作方法，比如 `arr.len()`，都是隐式地将它先转换成相应的切片，再调用切片
提供的方法。

## 切片 Slices
用于存放相同数据类型的一堆数据. 包括两部分属性, 其一是数据类型, 其二是元素个数. 这些都是要在编译期确定的. 写法是: `[T; size]`. 其中的元素被存放在一段连续的内存中, 位于栈上, 所以其占用的内存大小受限.

初始化数组:
* 一次性确定所有元素, `let xs = [1, 2, 3, 5, 8, 13];`
* 使用默认值: `let xs = [1u64; 10];`

切片 slice,  可以认为是数组的访问代理, 本身并不存储实际的数据, 有两部分属性:
其一是指向具体数据的一个指针, 类型是 usize; 其二是该访问代理可访问的元素数目.
这两个属性都可以在运行期确定, 所以 slice 更为灵活. 被记为 `&[T]`.

可以将数组通过引用的方式自动转为 slice:
```rust
let xs = [42u64; 10];
let s = &xs;
```
也可以指定数据代理访问的范围, 即只允许访问其部分元素:
```rust
let xs = [42; 10];
let s = &xs[1..5];
```

Slice 写作 `[T]`，只指定了元素类型，并没有指定其长度；所以它不能直接存储为变量
或作为函数参数，而应该以引用的方式来使用。

切片引用（Reference to slice）又称作胖指针（fat pointer），因为它既有指针指向
切片的第一个元素，也记录其元素个数。

- 切片表示指向类似array或者 vector的指针，以及元素个数
- `&[T]` 表示不可变切片；一个值可以有多个不可变切片，因为它们都是只读的
- `&mut [T]` 表示可变切片，可修改元素的值；一个值只能最多有一个可变切片

会自动将 `&Vec<T>` 以及 `&[T]` 转换为切片引用。

array slice, 是两个 word 大小的对象, 第一个值是指向 array 内部某元素的指针; 第二
个值是定义长度. 类型签名是 `&[T]`.

array 可以直接转换 array slice:
```rust
let xs = [1, 1, 2, 3, 5];
do_something(&xs);
```

也可以只将array 的一部分元素转为 array slice:
```rust
let xs = [1, 1, 2, 3, 5];
do_something(&xs[1..3]);

其实 Slice 本身的类型签名是 `[T]`, 但在代码中并不能直接使用这个类型.
```
